## 13장 동시성

### 동시성이 필요한 이유?

- 동시성은 결합을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다.
- 흔히 단일 스레드 프로그램을 디버깅하는 프로그래머는 정지점을 정한 후 어느 정도 지점에 걸렸는지 살펴보면서 시스템 상태를 파악한다.
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.
- 구조적 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다.
- 구조적 개선만을 위해 동시성을 채택하는건 아니다. 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 직접적인 동시성 구현이 불가피하다.

### 동시성의 오해

- 동시성은 항상 성능을 높여준다.
    - 대기 시간이 아주 길어 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아지는 것이지, 항상 성능을 높여주는 것은 아니다.
- 동시성을 구현해도 설계는 변하지 않는다.
    - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
    - 실제로는 컨테이너가 어떻게 동작하는지 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다.

### 동시성의 진실

- 동시성은 다소 부하를 유발한다.
    - 성능 측면에서 부하가 걸리며 코드도 더 짜야 한다.
- 동시성은 복잡하다
    - 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기가 어렵다.
    - 진짜 결함을 간주되기보단 일회성 문제로 여겨 무시하기 쉽다.
- 동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.

### 동시성 방어 원칙

지금부터 동시성 코드가 일으키는 문제로부터 시스템을 방어하는 원칙과 기술을 소개한다. 

- 단일 책임 원칙
    - SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙
    - 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다.
- 따름 정리, 자료 범위를 제한하라
    - 객체 하나를 공유한 후 동일 필드를 수정하던 두 스레드가 서로 간섭함으로 인해 예상치 못한 결과를 내놓을 수 있다. 이 문제에 대한 해결 방안으로 공유 객체를 사용하는 코드 내 임계 영역을 synchronized 키워드로 보호하라고 권장한다.
- 따름 정리, 자료 사본을 사용하라
    - 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋으며 어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
- 따름 정리, 스레드는 가능한 독립적으로 구현하라
    - 각 스레드는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다. 그러면 각 스레드는 세상에 자신만 있는 듯이 돌아갈 수 있다.
- 스레드 환경에 안전한 컬렉션
    - ConcurrentHashMap은 거의 모든 상황에서 HashMap보다 빠르다. 동시 읽기/쓰기를 지원하며 자주 사용하는 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공되기에 자바 5 이상 사용 시 ConcurrentHashMap를 권장한다.
- 실행 모델을 이해하라
    - 생산자-소비자
        - 하나 이상의 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
        - 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다.
        - 생산자 스레드와 소비자 스레드가 사용하는 대기열은 한정된 자원이다.
    - 읽기-쓰기
        - 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어진다.
        - 따라서 읽기 스레드의 요구와 쓰기 스레드의 요구를 적절히 만족시켜 처리율도 적당히 높이고 기아도 방지하는 해법이 필요하다.
        - 간단한 전략은 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다.
        - 하지만 읽기 스레드가 계속 이어진다면 쓰기 스레드는 기아 상태에 빠진다.
        - 반면 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 계속 이어진다면 처리율이 떨어지기에 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다.
    - 식사하는 철학자들
        - 둥근 식탁에 철학자 무리에서 왼쪽 철학자나 오른쪽 철학자가 포크를 사용 중이면 포크를 내려놓을 때까지 대기해야 한다.
        - 이처럼 주의해서 설계하지 않으면 데드락, 라이브락, 처리율 저하, 효율성 저하 등을 겪는다.
    - 동기화되는 부분을 작게 만들어라
        - 자바에서 synchronized 키워드를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다.
        - 락은 스레드를 지연시키고 부하를 가중시킨다. 그러므로 여기저기 synchronized 키워드를 남발하는 것은 옳지 않다.
    - 올바른 종료 코드는 구현하기 어렵다.
        - 깔끔하게 종료되는 코드는 올바르게 구현하기 어려우며 가장 흔히 발생하는 문제는 데드락이다.
        - 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라

### 결론

- 무엇보다 먼저 SRP를 준수한다.
    - 스레드 코드를 테스트할 때는 전적으로 스레드만 테스트하며, 스레드 코드는 최대한 집약되고 작아야 한다.
- 동시성 오류를 일으키는 잠정적 원인을 철저히 이해한다.
    - 여러 스레드가 공유 자료를 조작하거나 자원 풀을 공유할 때 동시성 오류가 발생한다. 루프 반복을 끝내거나 프로그램을 깔끔하게 종료하는 등 경계 조건의 경우가 까다로우므로 특히 주의해야 한다.
- 사용하는 라이브러리와 기본 알고리즘을 이해한다.
    - 특정 라이브러리 기능이 기본 알고리즘과 유사한 어떤 문제를 어떻게 해결하는지 파악한다.
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
    - 공유하는 객체수와 범위를 최대한 줄인다. 클라이언트에게 공유 상태를 관리하는 책임을 떠넘기지 않는다. 필요하다면 객체 설계를 변경해 클라이언트에게 편의를 제공한다.
- 어떻게는 문제는 생긴다.
    - 그러므로 스레드 코드는 많은 플랫폼에서 많은 설정으로 반복해서 계속 테스트해야 한다.
